<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <H1>What I learned about JS</H1>
    <p>En programmation, les nombres entiers sont aussi appelés entiers ou integers ; les nombres avec des chiffres après la virgule sont aussi appelés nombres en virgule flottante ou floating-point.
    </p>

    <h2>Class</h2>
    <p>
    A class allows you to create objects faster. Here is how to create one :
    class Book {
        constructor(title, author, pages) {
            this.title = title;
            this.author = author;
            this.pages = pages;
        }
    }
    </p>
    <p>
    Then use new to create classes :
    let myBook = new Book("L'Histoire de Tao", "Will Alexander", 250);
    //Cette ligne crée l'objet suivant :
    {
        title: "L'Histoire de Tao",
        author: "Will Alexander",
        pages: 250
    }
        </p>

    <h2>Arrays</h2>
    <p>let guests = ["Sarah Kate", "Audrey Simon", "Will Alexander"];</p>

    <h3>Length :</h3>
    <p>guests = ["Will Alexander", "Sarah Kate", "Audrey Simon"]; <br>
    let howManyGuests = guests.length;</p>

    <h3>Push :</h3>
    <p>guests.push("Tao Perkington"); // ajoute "Tao Perkington" à la fin de notre tableau guests</p>

    <h3>Unshift :</h3>
    <p>guests.unshift("Tao Perkington"); // "Tao Perkington" est ajouté au début du tableau guests</p>

    <h3>Pop :</h3>
    <p>guests.pop(); // supprimer le dernier élément du tableau</p>

    <h2>Logical comparisons</h2>

    <p>let userLoggedIn = true; <br><br>
    let UserHasPremiumAccount = true; <br>
    let userHasMegaPremiumAccount = false; <br><br>

    userLoggedIn && userHasPremiumAccount; // true <br>
    userLoggedIn && userHasMegaPremiumAccount; // false <br><br>

    userLoggedIn || userHasPremiumAccount; // true <br>
    userLoggedIn || userHasMegaPremiumAccount; // true <br><br>

    !userLoggedIn; // false <br>
    !userHasMegaPremiumAccount; // true <br> </p>

   <h2>Loops</h2>

    <h3>For :</h3>
    const numberOfPassengers = 10;<br>
    for (let i = 0; i < numberOfPassengers; i++) {<br>
    console.log("Passager embarqué !");<br>
    }
    
    <h3>For in :</h3>
    const passengers = [<br>
    "Will Alexander",<br>
    "Sarah Kate'",<br>
    "Audrey Simon",<br>
    "Tao Perkington"<br>
    ]<br>

    for (let i in passengers) {<br>
    console.log("Embarquement du passager " + passengers[i]);<br>
    }<br>
    i starts at 0 and +1 at each loop.<br>
    This is useful when manipulating a precise i in iteration.<br>

    <h3>For of :</h3>
    const passengers = [<br>
    "Will Alexander",<br>
    "Sarah Kate",<br>
    "Audrey Simon",<br>
    "Tao Perkington"<br>
    ]<br>

    for (let passenger of passengers) {<br>
    console.log("Embarquement du passager " + passenger);<br>
    }<br>
    If precise i not necessary, it is easier to use for of.<br>

    Even more useful if array has objects : <br>
    const passengers = [<br>
    {<br>
        name: "Will Alexander",<br>
        ticketNumber: 209542<br>
    },<br>
    
    {<br>
        name: "Sarah Kate",<br>
        ticketNumber: 169336<br>
    }]<br><br>
    for (let passenger of passengers) {<br>
    console.log('Embarquement du passager ' + passenger.name + ' avec le ticket numéro ' + passenger.ticketNumber);<br>
    }<br>

    <h3>While</h3>

    let seatsLeft = 10;<br>
    let passengersStillToBoard = 8;<br>
    let passengersBoarded = 0;<br><br>

    while (seatsLeft > 0 && passengersStillToBoard > 0) {<br>
        passengersBoarded++; // un passager embarque<br>
        passengersStillToBoard--; // donc il y a un passager de moins à embarquer<br>
        seatsLeft--; // et un siège de moins<br>
    }<br><br>

    console.log(passengersBoarded); // imprime 8, car il y a 8 passagers pour 10 sièges<br><br>

    <h3>For and while :</h3>
    - for, when we know the number of iterations<br>
    - while, when we don't<br><br>


    <h2>Méthodes d'instances et classes</h2>


    Il est possible d'ajouter des méthodes d'instance aux classes, des fonctions aux classes :<br>
    class BankAccount {<br>
        constructor(owner, balance) {<br>
           this.owner = owner;<br>
           this.balance = balance;<br>
        }<br>
        showBalance() {<br>
           console.log("Solde: " + this.balance + " EUR");<br>
        }<br>
     }<br>
     La classe étant en création on utilise "this."<br><br>

     Si l'on utilise la classe :<br><br>

     const newAccount = new BankAccount("Will Alexander", 500);<br>

    newAccount.showBalance(); // imprime "Solde: 500 EUR" à la console<br>

    <h2>Static classes :</h2>
    A method or a property that belong to a class and not the object.<br>
    class BePolite {<br><br>
    
        static sayHello() {<br>
            console.log("Hello!");<br>
        }<br>
        constructor(greetings){<br>
            this.greetings=greetings;<br>
        }    <br>
    }<br>
    sayHello is attached to BePolite, and is independant from greetings.<br><br>

    <h2>DOM</h2>

    <h3>getElementById</h3>
    <p>document.getElementById()</p>
    <p>document.getElementsByClassName() creates an array</p>
    <p>document.getElementsByTagName() creates an array</p>
    <p>document.querySelector() exemple : document.querySelector("#myId p.article > a") renvoie le premier élément qui correspond à cette description ou NULL si aucun élément trouvé</p>
    <p>querySelectorAll pour obtenir une liste avec TOUS les éléments</p>

    <h3>Element</h3>
    <p>Exemple : const elt = document.getElementById('main');</p>
    <p>elt.children - children de l'element<br>

        elt.parentElement - parent de l'element<br>
        
        elt.nextElementSibling - next sibling de l'element<br>
        
        elt.previousElementSibling - previous sibling de l'element</p>

    <h3>Change the DOM</h3>
    <p><b>textContent :</b><br>modifie ou récupère le texte d'un élément <br>
    Exemple : <br>
    // On obtient le contenu textuel : <br>
    var text = document.getElementById("div").textContent;<br>
    // On définit le contenu textuel :<br>
    document.getElementById("div").textContent = "Ceci est un exemple de texte";</p>

    <p><b>innerHTML</b> modifie ou récupère le contenu HTML d'un élément <br>
        Exemple : <br>
        let elt = document.getElementById('main');
        elt.innerHTML = "< ul>< li>Elément 1< / li>< li>Elément 2< / li> < / ul>";
    </p>

    <p><b>Change the class</b> <br>
        elt.classList.add("nouvelleClasse");    // Ajoute la classe nouvelleClasse à l'élément <br>
        elt.classList.remove("nouvelleClasse"); // Supprime la classe nouvelleClasse que l'on venait d'ajouter <br>
        elt.classList.contains("nouvelleClasse");   // Retournera false car on vient de la supprimer <br>
        elt.classList.replace("oldClass", "newClass"): // Remplacera oldClass par newClass si oldClass était présente sur l'élément <br>
    </p>

    <p><b>Change the style</b><br>
        elt.style.color = "#fff";      // Change la couleur du texte de l'élément à blanche <br>
        elt.style.backgroundColor = "#000"; // Change la couleur de fond de l'élément en noir <br>
        elt.style.fontWeight = "bold"; // Met le texte de l'élément en gras <br>
    </p>

    <p><b>Change the attribute</b><br>
        Pour définir ou remplacer les attributs d'un élément, vous pouvez utiliser la fonction  setAttribute . <br>
        element.setAttribute(< name >, < value > ) prend en paramètres le nom de l'attribut et sa valeur. <br>
        Exemple : <br>
        elt.setAttribute("type", "password");   // Change le type de l'input en un type password <br>
        elt.setAttribute("name", "my-password");    // Change le nom de l'input en my-password <br>
        elt.getAttribute("name");               // Retourne my-password <br>
        elt.removeAttribute("name");               // Supprime my-password <br>
    </p>

    <p><b>Create, replace, remove children</b><br>
        Create new element then add it as a child to another one : <br>
        const newElt = document.createElement("div");<br>
        let elt = document.getElementById("main");<br>

        elt.appendChild(newElt);<br>

        elt.removeChild(newElt);    // Supprime l'élément newElt de l'élément elt <br>
        elt.replaceChild(document.createElement("article"), newElt);    // Remplace l'élément newElt par un nouvel élément de type article <br>
    </p>

    <h2>Events</h2>

    <h3>onClick</h3>
    <p>const elt = document.getElementById('mon-lien');    // On récupère l'élément sur lequel on veut détecter le clic <br>
        elt.addEventListener('click', function() {          // On écoute l'événement click <br>
            elt.innerHTML = "C'est cliqué !";               // On change le contenu de notre élément pour afficher "C'est cliqué !" <br>
        });
    </p>

    <h3>preventDefault()</h3>
    <p>Permet d'empecher l'execution de l'évènement par default entrainé par action, comme l'ouverture d'une page après un click sur un lien <br>
    Exemple : <br>
    const elt = document.getElementById('mon-lien');    // On récupère l'élément sur lequel on veut détecter le clic <br>
    elt.addEventListener('click', function(event) {     // On écoute l'événement click, notre callback prend un paramètre que nous avons appelé event ici <br>
    event.preventDefault();                         // On utilise la fonction preventDefault de notre objet event pour empêcher le comportement par défaut de cet élément lors du clic de la souris <br>
    }); <br>
    </p>

    <h3>stopPropagation()</h3>
    <p>Permet de stopper la propagation. Si on click sur un élément intérieur, et qu'on ne veut pas que ce click se propage à l'élément qui le contient. <br>
    Exemple : <br>
    elementInterieur.addEventListener('click', function(event) { <br>
    event.stopPropagation(); <br>
    elementAvecMessage.innerHTML = "Message de l'élément intérieur"; <br>
    });
    </p>

    <h3>Track the mouse</h3>
    <p>
        clientX  /  clientY  : position de la souris dans les coordonnées locales (contenu du DOM) ; <br>

        offsetX  /  offsetY  : position de la souris par rapport à l'élément sur lequel on écoute l'événement ; <br>
    
        pageX  /  pageY  : position de la souris par rapport au document entier ; <br>
    
        screenX  /  screenY  : position de la souris par rapport à la fenêtre du navigateur ; <br>
    
        movementX  /  movementY  : position de la souris par rapport à la position de la souris lors du dernier événement  mousemove <br>
        Exemmple : <br>
        elt.addEventListener('mousemove', function(event) { <br>
            const x = event.offsetX; // Coordonnée X de la souris dans l'élément <br>
            const y = event.offsetY; // Coordonnée Y de la souris dans l'élément <br>
        });
    </p>

    <h3>Track changes in text</h3>
    <p>
        Change : event is triggered when the area looses the focus. Works with < input>, < select> et < textarea>. And checkbox and radio. <br>
        Input : same but when text is changed, even if user is not done. <br>
        Exemple : <br>
        input.addEventListener('input', function(event) { <br>
            output.innerHTML = event.target.value; <br>
        }); <br>
    </p>

    <h2>API et requête</h2>

    <h3>JSON</h3>
    <p>
        JSON signifie JavaScript Object Notation <br>
        JV object : <br>
        const obj = { <br>
            name: "Mon contenu", <br>
            id: 1234, <br>
            message: "Voici mon contenu", <br>
            author: { <br>
                name: "John" <br>
            }, <br>
            comments: [ <br>
                { <br>
                    id: 45, <br>
                    message: "Commentaire 1" <br>
                }, <br>
                { <br>
                    id: 46, <br>
                    message: "Commentaire 2" <br>
                } <br>
            ] <br>
        }; <br>

        In JSON  : <br>
        { <br>
            "name": "Mon contenu", <br>
            "id": 1234, <br>
            "message": "Voici mon contenu", <br>
            "author": { <br>
                "name": "John" <br>
            }, <br>
            "comments": [ <br>
                { <br>
                    "id": 45, <br>
                    "message": "Commentaire 1" <br>
                }, <br>
                { <br>
                    id: 46, <br>
                    "message": "Commentaire 2" <br>
                } <br>
            ] <br>
        } <br>
        En JavaScript, votre objet est assigné à une variable, alors qu'en JSON on ne fait que décrire une structure. <br> </p>

    <h3>GET</h3>
    <p>
        Appel : <br>
        fetch("http://url-service-web.com/api/users"); <br>
        Si simple écho : <br>
        fetch(“https://mockbin.com/request”) <br>
        .then(function(res) { <br>
            if (res.ok) { <br>
            return res.json(); <br>
            } <br>
        }) <br>
        .then(function(value) { <br>
            console.log(value); <br>
        }) <br>
        .catch(function(err) { <br>
            // Une erreur est survenue br
        }); <br>
        Vous pouvez voir dans l'exemple ci-dessus que l'URL passée à la fonctionfetch() a changé et correspond à l’URL de notre service web. <br>
        Le type de requête est GET (ce qui est le cas par défaut avec Fetch) <br>
        car nous voulons récupérer les données. <br>

        Ensuite nous appelons la fonctionthen()pour récupérer le résultat de la requête au format json <br>
        en ayant vérifié au préalable que la requête s’était bien passée avec res.ok. <br>
        Ce résultat json étant lui aussi une Promise, nous le retournons et récupérons sa vraie valeur dans la fonction then() suivante. <br>
    </p>
</body>
</html>